# R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

## Including Plots

插入图像

```{r lena,fig.cap="lena", echo=FALSE,small.mar = TRUE,out.width="45%",fig.asp=1}
library(png)
library(jpeg)
library(bmp)
library(IM)
# create an object of class "Image"
data(lena)
obj = new("Image",img=img)
# display image
displayImg(obj@I)
```

分组散点图添加平滑线和回归线

```{r scatter-iris, echo=FALSE,fig.cap="线性回归模型",out.width="45%",fig.asp=1}
library(car)
scatterplot(Sepal.Length ~ Sepal.Width, col = c("black","red","blue"), pch=c(16,16,16),
            smooth = TRUE, boxplots = "xy", groups = iris$Species, 
            xlab = "Sepal.Width", ylab = "Sepal.Length", data = iris
)
```

插入 TikZ 制作的图形，一行两列

```{r linear-model,dev='tikz',fig.cap="线性回归模型",echo=FALSE,fig.pos="!htb",out.width="35%",fig.show='hold',fig.asp=1,fig.width=3.5}
# 带有图标题
par(mar = c(4.1, 4.1, 4.5, 1.5), ps = 13, family = "Times")
x <- rnorm(10)
y <- x + rnorm(5, sd = 0.25)
model <- lm(y ~ x)
rsq <- summary(model)$r.squared
rsq <- signif(rsq, 4)
plot(x, y, main = "Hello \\LaTeX!", xlab = "$x$", ylab = "$y$")
abline(model, col = "red")
mtext(paste("Linear model: $R^{2}=", rsq, "$"), line = 0.5)
legend("bottomright", legend = paste("$y = ", round(coef(model)[2], 3),
  "x +", round(coef(model)[1], 3), "$",
  sep = ""
), bty = "n")

plot(x, y, main = "Hello \\LaTeX!", xlab = "$x$", ylab = "$y$")
abline(model, col = "red")
mtext(paste("Linear model: $R^{2}=", rsq, "$"), line = 0.5)
legend("bottomright", legend = paste("$y = ", round(coef(model)[2], 3),
  "x +", round(coef(model)[1], 3), "$",
  sep = ""
), bty = "n")
```

```{r bessel-function,dev='tikz',fig.cap="贝塞尔函数",echo=FALSE,fig.pos="!htb",out.width="35%",fig.show='hold',fig.asp=1,fig.width=2.5}
x0 <- 2^(-20:10)
nus <- c(0:5, 10, 20)
x <- seq(0, 4, length.out = 501)

plot(x0, x0^-8,frame.plot=TRUE,
     log = "xy", xlab = "$u$", axes = FALSE,
     ylab = "$\\mathcal{K}_{\\kappa}(u)$", 
     type = "n", ann = TRUE, panel.first = grid()
) # x 和 y 轴都取对数

axis(1,
     at = c(1e-08, 1e-06, 1e-04, 1e-02, 1, 1e+02),
     labels = expression(10^-8, 10^-6, 10^-4, 10^-2, 1, 10^2)
)
axis(2,
     at = c(1e-16, 1, 1e+16, 1e+32, 1e+48),
     labels = expression(10^-16, 1, 10^16, 10^32, 10^48), las = 1
)
# 设置线条颜色
cols <- RColorBrewer::brewer.pal(9,name = "Spectral")
# gray.colors(9) terrain.colors(9)  RColorBrewer::brewer.pal(9,name = "Spectral")
for (i in seq(length(nus)))
  lines(x0, besselK(x0, nu = nus[i]), col = cols[i], lwd = 2)
legend("topright",legend = paste0("$\\kappa=", rev(nus),"$"),
       col = rev(cols), lwd = 2, cex = 0.5)

# 数据变化范围太大，因此横纵坐标轴都取了以10为底的对数，数据可以紧凑的在一张图内展示
x <- seq(0, 40, length.out = 801)
x <- x[x > 0]
plot(x, x,frame.plot=TRUE,
     ylim = c(1e-18, 1e11), log = "y", xlab = "$u$", type = "n",  yaxt = "n",
     ylab = "$\\mathcal{K}_{\\kappa}(u)$", ann = TRUE, panel.first = grid()
)
axis(2,
     at = c(1e-19, 1e-12, 1e-05, 1e+02, 1e+09),
     labels = expression(10^-19, 10^-12, 10^-5, 10^2, 10^9), las = 1
)

for (i in seq(length(nus)))
  lines(x, besselK(x, nu = nus[i]), col = cols[i], lwd = 2)
legend("topright", legend = paste0("$\\kappa=", rev(nus),"$"), 
       col = rev(cols), lwd = 2, cex = 0.5)
```

```{r wind-rose,fig.cap="风玫瑰图",echo=FALSE,fig.asp=1,out.width="45%",fig.width=4.5}
# 风玫瑰图 http://blog.csdn.net/Bone_ACE/article/details/47624987
library(ggplot2)
set.seed(2018)
# 随机生成100次风向，并汇集到16个区间内
direction <- cut_interval(runif(100, 0, 360), n = 16)
# 随机生成100次风速，并划分成4种强度
mag <- cut_interval(rgamma(100, 15), 4)
dat <- data.frame(direction = direction, mag = mag)
# 将风向映射到X轴，频数映射到Y轴，风速大小映射到填充色，生成条形图后再转为极坐标形式即可
p <- ggplot(dat, aes(x = direction, y = ..count.., fill = mag))
p + geom_bar(colour = "white") +
  coord_polar() +
  theme_minimal() +
  theme(axis.ticks = element_blank(), axis.text.y = element_blank()) +
  labs(x = "", y = "", fill = "Magnitude")

# p + geom_bar(position = "stack") +
#   coord_polar() +
#   theme_minimal() +
#   theme(axis.ticks = element_line(colour = "white"))
```

```{r bivariate-normal-density,fig.cap="二元正态概率密度函数",echo=FALSE,fig.width=8,out.width="90%"}
# library(latex2exp)
# 代码来自  http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf
mu1 <- 0 # setting the expected value of x1
mu2 <- 0 # setting the expected value of x2
s11 <- 10 # setting the variance of x1
s12 <- 15 # setting the covariance between x1 and x2
s22 <- 10 # setting the variance of x2
rho <- 0.5 # setting the correlation coefficient between x1 and x2
x1 <- seq(-10, 10, length = 41) # generating the vector series x1
x2 <- x1 # copying x1 to x2
 # setting up the function of the multivariate normal density
f <- function(x1, x2) {
  term1 <- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2)))
  term2 <- -1 / (2 * (1 - rho^2))
  term3 <- (x1 - mu1)^2 / s11
  term4 <- (x2 - mu2)^2 / s22
  term5 <- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22))
  term1 * exp(term2 * (term3 + term4 - term5))
}
z <- outer(x1, x2, f) # calculating the density values
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
# jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
# color <- jet.colors(nbcol)
color <- viridisLite::viridis(100)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
# Recode facet z-values into color indices
facetcol <- cut(zfacet, nbcol)

par(mar = c(4.1, 4.1, 4.5, 1.5), ps = 10)
persp(x1, x2, z,
  xlab = "x1",
  ylab = "x2",
  zlab = "f(x1,x2)",
  # xlab = TeX('$x_{1}$'), # latex2exp 其实是使用 LaTeX 语法将 LaTeX 公式翻译为 R 能接受的表达式形式
  # ylab = TeX('$x_{2}$'),
  # zlab = TeX('$f(x_{1},x_{2})$'),  
  main = "Two dimensional Normal Distribution",
  col = color[facetcol], border = NA, theta = 30, phi = 20,
  r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180,
  shade = 0.1, ticktype = "detailed", nticks = 5, box = TRUE
) 
mtext(expression(list(mu[1] == 0, mu[2] == 0, sigma[11] == 10, 
                      sigma[22] == 10, sigma[12] == 15, rho == 0.5)), 
      side = 3)

mtext(expression(italic(f) ~ group("(",list(x[1],x[2]),")") == frac(1, 2 ~ pi ~ sqrt(sigma[11] ~ sigma[22] ~ (1 - rho^2))) ~ exp ~
  bgroup("{", 
         paste(
           - frac(1, 2(1 - rho^2)) * phantom(0),
               bgroup("[",  
                          frac((x[1] ~ -~mu[1])^2, sigma[11]) ~ 
                        -~2 ~ rho ~ frac(x[1] ~ -~mu[1], sqrt(sigma[11])) ~ frac(x[2] ~ -~mu[2], sqrt(sigma[22])) ~ 
                        +~frac((x[2] ~ -~mu[2])^2, sigma[22]),
                      "]")
               ),
    "}")
  ), side = 1, line = 3)
```

```{r tikz-bivariate-normal-density,dev='tikz',fig.cap="二元正态密度函数",echo=FALSE,fig.width=8,out.width="90%"}
# 代码来自  http://www.ejwagenmakers.com/misc/Plotting_3d_in_R.pdf
# 3-D plots
mu1 <- 0 # setting the expected value of x1
mu2 <- 0 # setting the expected value of x2
s11 <- 10 # setting the variance of x1
s12 <- 15 # setting the covariance between x1 and x2
s22 <- 10 # setting the variance of x2
rho <- 0.5 # setting the correlation coefficient between x1 and x2
x1 <- seq(-10, 10, length = 41) # generating the vector series x1
x2 <- x1 # copying x1 to x2
f <- function(x1, x2) {
  term1 <- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2)))
  term2 <- -1 / (2 * (1 - rho^2))
  term3 <- (x1 - mu1)^2 / s11
  term4 <- (x2 - mu2)^2 / s22
  term5 <- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22))
  term1 * exp(term2 * (term3 + term4 - term5))
} # setting up the function of the multivariate normal density
z <- outer(x1, x2, f) # calculating the density values
nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
# jet.colors <- colorRampPalette( c("blue", "green") )
# Generate the desired number of colors from this palette
nbcol <- 100
# color <- jet.colors(nbcol)
color <- viridisLite::viridis(100)
# Compute the z-value at the facet centres
zfacet <- z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz]
# Recode facet z-values into color indices
facetcol <- cut(zfacet, nbcol)
par(mar = c(4.1, 4.1, 4.5, 1.5))
# op <- par(mar = c(4, 3, 3, 0.5))
persp(x1, x2, z,
      xlab = "$x_{1}$",
      ylab = "$x_{2}$",
      zlab = "$f(x_{1},x_{2})$",
      main = "Two dimensional Normal Distribution",
      col = color[facetcol], border = NA, theta = 30, phi = 20,
      r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180,
      shade = 0.1, ticktype = "detailed", nticks = 5, box = TRUE
)
mtext("$\\mu_1 = 0,\\mu_2 = 0,\\sigma_{11} = 10,\\sigma_{22} = 10,\\sigma_{12} = 15, \\rho = 0.5$", side = 3)
mtext("$f(x_{1},x_{2}) = \\frac{1}{2\\pi\\sqrt{\\sigma_{11}\\sigma_{22}(1-\\rho^2)}}\\exp\\big\\{-\\frac{1}{2(1-\\rho^2)}[\\frac{(x_1 - \\mu_1)^2}{\\sigma_{11}} - 2\\rho\\frac{(x_1 - \\mu_1)(x_2 - \\mu_2)}{\\sqrt{\\sigma_{11}}\\sqrt{\\sigma_{22}}} + \\frac{(x_2 - \\mu_2)^2}{\\sigma_{22}}]\\big\\}$", 
      side = 1, line = 2, cex = 1.5)
# par(op)
```


```{r lattice,fig.cap="表达式二元密度函数",echo=FALSE,fig.width=8,out.width="90%"}
library(lattice)
wireframe(z ~ x1 + x2,
  data = data.frame(x1 = x1, x2 = rep(x2, each = length(x1)), z = z),
  xlab = expression(x[1]), ylab = expression(x[2]),
  zlab = expression(italic(f) ~ group("(",list(x[1],x[2]),")")))
```

```{r unicode-math-Greek-letters,fig.cap="希腊字母用 unicode 字符代替",echo=FALSE,dev='cairo_pdf'}
# https://stackoverflow.com/questions/41190525/adjust-margins-in-persp-persp3d-in-r
# https://stackoverflow.com/questions/37571376/how-to-customize-nticks-in-persp-r
# https://stackoverflow.com/questions/43507680/are-xlab-ylab-and-zlab-in-persp-incompatible-with-bquote
x <- seq(-10, 10, len = 30)
y <- seq(0, 5, len = 30)
f <- function(x, y) {
  dnorm(2, x, y)
}
z <- outer(x, y, f)
# Try using unicode symbols 代替希腊字母
# 一般表达式如何转 unicode 字符 
# cairo_pdf(file="test.pdf") # 不要使用 pdf 不然 sigma 不能正确渲染
persp(x, y, z,
  theta = 30, phi = 30, expand = 0.5, col = "lightblue",
  xlab = "\u03bc", ylab = "\u03c3",
  zlab = paste("Likelihood ", "(\u03bc,\u03c3)", sep = "")
)
```

